+++
title = "2.2.6 Verify that the application works"
chapter = false
weight = 50
+++

The other two components of our application will be created in a very similar way so we have already configured them. 

The Dockerfile used for frontend is also very simple, based on the ruby:2.7.2-slim-buster image. It installs a few other tools, then runs a docker-entrypoint shell script which specifies some environment variables and runs puma which is a special web server. 

1.  If you weren't able to complete the last section or the yaml file doesn't work, run this command to reset the files: `cp -i ~/sourcefiles/completedfiles/15f27d1a54 ~/environment/section2/db.yaml;cp -i ~/sourcefiles/completedfiles/ba34a9f273 ~/environment/section2/discounts.yaml;cp -i ~/sourcefiles/completedfiles/a4c32db14d ~/environment/section2/dbpassword.yaml`. 
2.  And now the app should be all setup. Deploy all of the yaml files: `k apply -f .`
3.  Now we have successfully migrated our application from a traditional VM based environment to a Kubernetes environment. This was a simple application but the process showed you what most of the parts of a configuration file are for and how you can build one too. 
4.  Run this command to get the External IP for our service: `k get services`. This will show something like **a95247arandom7919b2e492a6-1b9a8random12b.elb.us-west-2.amazonaws.com**. This is generated by AWS because of the annotation on the service. This can take a few minutes to provision. From the AWS console, you can look at Load Balancers under the EC2 service, and then find the new load balancer. It will probably say **provisioning** and when done that will change to **active**
5.  Now open the browser to the URL listed for External IP. If the site isn't available, try running `k get pods` to see if all the pods are running. It can take a minute for them to start completely. ![storedog frontpage](/images/dd-storedog-frontpage.png)


