+++
title = "2.2.6 Deploy the Frontend"
chapter = false
weight = 50
+++

Now let's deploy the fourth component of the application: the front end server. This is a Ruby on Rails based application which calls out to discounts and ads and displays products from the database. 

1.  If you weren't able to complete the last section or the yaml file doesn't work, run this command to reset the advertisements.yaml file: `cp -i ~/sourcefiles/completedfiles/14ba843c6c ~/environment/section2/advertisements.yaml;k apply -f .`
2.  The Dockerfile used for this component is also very simple, based on the ruby:2.7.2-slim-buster image. It installs a few other tools, then runs a docker-entrypoint shell script which specifies some environment variables and runs puma which is a special web server. 
3.  Open the empty **frontend.yaml** file.
4.  Add the following content to that yaml file:
        
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          labels:
            service: frontend
            app: ecommerce
          name: frontend
        spec:
          replicas: 1
          selector:
            matchLabels:
              service: frontend
              app: ecommerce
          strategy:
            rollingUpdate:
              maxSurge: 25%
              maxUnavailable: 25%
            type: RollingUpdate
          template:
            metadata:
              labels:
                service: frontend
                app: ecommerce
            spec:
              containers:
              - args:
                - docker-entrypoint.sh
                command:
                - sh
                env:
                - name: DB_USERNAME
                  value: user
                - name: DB_PASSWORD
                  valueFrom:
                    secretKeyRef:
                      key: pw
                      name: db-password
                image: ddtraining/ecommerce-frontend:latest
                imagePullPolicy: Always
                name: ecommerce-spree-observability
                ports:
                - containerPort: 3000
                  protocol: TCP
                resources:
                  requests:
                    cpu: 100m
                    memory: 100Mi
                  limits: {}
        ---
        apiVersion: v1
        kind: Service
        metadata:
          labels:
            service: frontend
            app: ecommerce
          name: frontend
          annotations:
            service.beta.kubernetes.io/aws-load-balancer-type: "nlb"  
        spec:
          ports:
            - port: 80
              protocol: TCP
              targetPort: 3000
              name: http
          selector:
            service: frontend
            app: ecommerce
          type: LoadBalancer
5.  And now the app should be all setup. Deploy the yaml files: `k apply -f .`
6.  Now we have successfully migrated our application from a traditional VM based environment to a Kubernetes environment. This was a simple application but the process showed you what most of the parts of a configuration file are for and how you can build one too. 
7.  Run this command to get the External IP for our service: `k get services`. This will show something like **a95247arandom7919b2e492a6-1b9a8random12b.elb.us-west-2.amazonaws.com**. This is generated by AWS because of the annotation on the service. This can take a few minutes to provision. From the AWS console, you can look at Load Balancers under the EC2 service, and then find the new load balancer. It will probably say **provisioning** and when done that will change to **active**
8.  Now open the browser to the URL listed for External IP. If the site isn't available, try running `k get pods` to see if all the pods are running. It can take a minute for them to start completely. ![storedog frontpage](/images/dd-storedog-frontpage.png)


